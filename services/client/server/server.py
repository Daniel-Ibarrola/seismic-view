import asyncio
import argparse
import json
import logging

import numpy as np
import signal
from typing import Any, Callable, Optional
import websockets


class WaveGenerator:
    """ A generator of sine waves.
    """

    def __init__(self,
                 size: int = 100,
                 n_samples: int = 10,
                 stop: bool = False,
                 change_period: bool = True
                 ):
        self.data = np.linspace(0, 2*np.pi, size).tolist()
        self.index = 0
        self.period = 4
        self.change_period = change_period
        self.n_samples = n_samples
        self.stop = stop

    def __iter__(self):
        return self

    def __next__(self):
        if self.change_period and self.period > 5:
            self.period = 1

        if not self.stop:
            if self.index < len(self.data):
                values = []
                for _ in range(self.n_samples):
                    sine = np.sin(self.period * self.data[self.index]) * 100
                    values.append(sine)
                    self.index += 1
                return values
            else:
                self.index = 0
                if self.change_period:
                    self.period += 0.5
                return self.__next__()
        raise StopIteration


class WSServer:
    """A websocket server that sends wave data continuously to multiple clients.

        The station data is sent in json format and has the following schema:

        data = {
            "station": str,
            "channel": str,
            "min": float,
            "max": float,
            "avg": float,
            "trace": list[float]
        }

        The waves are generated by a sine function.
    """
    def __init__(
            self,
            address: tuple[str, int],
            logger: logging.Logger,
            wave_gen: WaveGenerator
    ):
        self.host = address[0]
        self.port = address[1]
        self.connections = {}  # type: dict[websockets.WebSocketServerProtocol, str]
        self.wave_gen = wave_gen

        self.sending = asyncio.Event()
        self.logger = logger

    def add_stop_listener(self, listener: Optional[Callable] = None, *args):
        loop = asyncio.get_event_loop()
        for sig_name in {'SIGINT', 'SIGTERM'}:
            if listener is None:
                loop.add_signal_handler(getattr(signal, sig_name),
                                        lambda: asyncio.ensure_future(self.stop()))
            else:
                loop.add_signal_handler(getattr(signal, sig_name),
                                        lambda: asyncio.ensure_future(listener(*args)))

    async def stop(self) -> None:
        self.logger.info(f"Stopping {self.__class__.__name__}...")
        self.wave_gen.stop = True
        tasks = [task for task in asyncio.all_tasks() if task is not asyncio.current_task()]
        for task in tasks:
            task.cancel()

        await asyncio.gather(*tasks, return_exceptions=True)
        asyncio.get_event_loop().stop()

    @staticmethod
    def channel_data(
            station: str,
            channel: str,
            min_: float,
            max_: float,
            mean: float,
            trace: list[float]
    ) -> dict[str, Any]:
        return {
            "station": station,
            "channel": channel,
            "min": min_,
            "max": max_,
            "mean": mean,
            "trace": trace,
        }

    def wave_json(self, station: str) -> list[dict[str, Any]]:
        """ Returns data for the 3 channels of station. """
        trace = next(self.wave_gen)
        min_ = min(trace)
        max_ = max(trace)
        mean = sum(trace) / len(trace)
        return [
            self.channel_data(station, "HLZ", min_, max_, mean, trace),
            self.channel_data(station, "HL2", min_, max_, mean, trace),
            self.channel_data(station, "HL1", min_, max_, mean, trace),
        ]

    async def send_station_data(
            self,
            connections: dict[websockets.WebSocketServerProtocol, str],
    ) -> None:
        """ Sends data of the requested station.
        """
        if connections:
            # TODO: if a client is disconnected the size of connections can change leading
            #  to a runtime error
            self.sending.clear()
            for ws, station in connections.items():
                json_data = self.wave_json(station)
                for jdata in json_data:
                    msg = json.dumps(jdata)
                    try:
                        await ws.send(msg)
                    except websockets.ConnectionClosedOK:
                        break
                    # await asyncio.sleep(0.1)
            await asyncio.sleep(1)
            self.sending.set()
        else:
            await asyncio.sleep(0.5)

    async def handle_new_connection(
            self,
            ws: websockets.WebSocketClientProtocol
    ) -> None:
        try:
            station = await ws.recv()
        except websockets.ConnectionClosedOK:
            return

        self.logger.info(f"{ws.id} connected. Requested station {station}")

        self.connections[ws] = station

        try:
            await ws.wait_closed()
        finally:
            self.logger.info(f"Disconnected {ws.id}")
            await self.sending.wait()
            del self.connections[ws]

    async def send(self) -> None:
        while True:
            await self.send_station_data(self.connections)

    async def start(self) -> None:
        self.logger.info(f"{self.__class__.__name__} listening on {self.host}:{self.port}")
        server = await websockets.serve(self.handle_new_connection, self.host, self.port)

        try:
            await self.send()
        except asyncio.CancelledError:
            # When the send_message task is cancelled, stop the WebSocket server gracefully
            server.close()
            await server.wait_closed()
            self.logger.info(f"{self.__class__.__name__} stopped")


def parse_args() -> tuple[str, int, bool]:
    parser = argparse.ArgumentParser(
        description="Websocket client to test the EarthWormGrapher client")
    parser.add_argument(
        "--ip",
        "-i",
        type=str,
        default="localhost",
        help="The ip where the client will connect"
             " (default localhost)."
    )
    parser.add_argument(
        "--port",
        "-p",
        type=int,
        default=13345,
        help="The port where the client will connect"
             " (default 12345)."
    )
    parser.add_argument(
        "--change-period",
        "-cp",
        action="store_true",
        help="Whether to change the period of the sine "
             "function"
    )
    args = parser.parse_args()
    return args.ip, args.port, args.change_period


def get_logger() -> logging.Logger:
    logger = logging.getLogger(__name__)
    formatter = logging.Formatter(
        '%(asctime)s [%(name)-12s] %(levelname)-5s %(message)s')
    stream_handler = logging.StreamHandler()
    stream_handler.setFormatter(formatter)
    logger.addHandler(stream_handler)
    logger.setLevel(logging.INFO)
    return logger


async def main() -> None:
    ip, port, change_period = parse_args()
    logger = get_logger()
    wave_gen = WaveGenerator(change_period=change_period)
    server = WSServer((ip, port), logger, wave_gen)

    server.add_stop_listener()
    await server.start()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass
